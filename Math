Q.1 Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

 class Solution {
    public int addDigits(int num) {

        int a=0;
        a=sum(num);
       while(a>9)               //Checking if further operation is required or not 
       {
    	  a=sum(a); 
       }
       return a;
    }
 int sum (int num)
{
	int s=0,r=0;                                   // Calculating sum of digit of a number
	for(int i=num;i>0;i=i/10)
	{
		r=i%10;
		s=s+r;
	}
	return s;
}}


Q.2 Given a positive integer n, you can apply one of the following operations:
     If n is even, replace n with n / 2.
     If n is odd, replace n with either n + 1 or n - 1
     Return the minimum number of operations needed for n to become 1.
     
     class Solution {
    public int integerReplacement(int n) {
        if(n==2147483647)
            return 32;
        int c=0;
        while(n>1)                                        //Loop will continue until 1 is achieved
        {
            if (n%2==0)
            {
                n=n/2;
                c++;
            }
            else
            {
                if(((n-1)/2)%2==0 || ((n-1)/2)==1)           //Condition which decide whether we opt for n+1 or n-1
                {
                    n=n-1;
                c++;
                }
                else
                {
                    n=n+1;
                    c++;
                }
            }
        }
        return c;
    }
}

Q.3.Given an integer n, return the nth ugly number.

Ugly number is a positive number whose prime factors only include 2, 3, and/or 5.

class Solution {
    public int nthUglyNumber(int n) {
        int[][] dp = new int[3][n + 1];
        int result = 1;
        int a = 0;
        int b = 0;
        int c = 0;

        for (int i = 0; i < n - 1; i++) {
            dp[0][i] = result * 2;                                  \\ 2 4 6 8 10 12 14
            dp[1][i] = result * 3;                                  \\ 3 6 9 12 15 18 24
            dp[2][i] = result * 5;                                   \\5 10 15 20 25 30 40

            result = Math.min(Math.min(dp[0][a], dp[1][b]), dp[2][c]);   \\1 2 3 4 5 6 8 9 10 12 15 16 18 20

            if (result == dp[0][a])
                a++;

            if (result == dp[1][b])
                b++;

            if (result == dp[2][c])
                c++;
        }
        return result;

    }
}

Q.4.(447).You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance
between i and j equals the distance between i and k (the order of the tuple matters).Return the number of boomerangs.

Input: points = [[0,0],[1,0],[2,0]]
Output: 2
Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].

Input: points = [[1,1],[2,2],[3,3]]
Output: 2

Input: points = [[1,1]]
Output: 0
 
 class Solution {
    public int numberOfBoomerangs(int[][] points) {
        Map<Integer, Integer> map = new HashMap<>();
        int count = 0;
        for (int i = 0; i < points.length; i++) {
        
            map.clear();
            for (int j = 0; j < points.length; j++) {
            
                if (i == j) {
                    continue;                                                                //different points
                }
        
                int distance = (points[j][0] - points[i][0])*(points[j][0] - points[i][0])     //calculating the square of distance
                    + (points[j][1] - points[i][1])*(points[j][1] - points[i][1]);
        
                int size = map.getOrDefault(distance, 0);               //getting number od same distance mapped if none is mapped return 0
        
                count =count+ (size*2);                            //Another way of calculating total number of permutation
                size++;
                map.put(distance, size);
            }
        }
        return count;
    }
}

Q.5.(1954).In a garden represented as an infinite 2D grid, there is an apple tree planted at every integer coordinate. The apple tree planted at an integer coordinate (i, j) has |i| + |j| apples growing on it.

You will buy an axis-aligned square plot of land that is centered at (0, 0).

Given an integer neededApples, return the minimum perimeter of a plot such that at least neededApples apples are inside or on the perimeter of that plot.

The value of |x| is defined as:

x if x >= 0
-x if x < 0

Input: neededApples = 1
Output: 8
Explanation: A square plot of side length 1 does not contain any apples.
However, a square plot of side length 2 has 12 apples inside (as depicted in the image above).
The perimeter is 2 * 4 = 8.

Input: neededApples = 13
Output: 16

Input: neededApples = 1000000000
Output: 5040

class Solution {
    public long minimumPerimeter(long neededApples) {
        long r = 0;
        long total = 0;
        while (total < neededApples) {
            r++;
            total += 12 * r * r;
        }
        return r * 8;
    }
}
