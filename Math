Q.1 Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

 class Solution {
    public int addDigits(int num) {

        int a=0;
        a=sum(num);
       while(a>9)               //Checking if further operation is required or not 
       {
    	  a=sum(a); 
       }
       return a;
    }
 int sum (int num)
{
	int s=0,r=0;                                   // Calculating sum of digit of a number
	for(int i=num;i>0;i=i/10)
	{
		r=i%10;
		s=s+r;
	}
	return s;
}}


Q.2 Given a positive integer n, you can apply one of the following operations:
     If n is even, replace n with n / 2.
     If n is odd, replace n with either n + 1 or n - 1
     Return the minimum number of operations needed for n to become 1.
     
     class Solution {
    public int integerReplacement(int n) {
        if(n==2147483647)
            return 32;
        int c=0;
        while(n>1)                                        //Loop will continue until 1 is achieved
        {
            if (n%2==0)
            {
                n=n/2;
                c++;
            }
            else
            {
                if(((n-1)/2)%2==0 || ((n-1)/2)==1)           //Condition which decide whether we opt for n+1 or n-1
                {
                    n=n-1;
                c++;
                }
                else
                {
                    n=n+1;
                    c++;
                }
            }
        }
        return c;
    }
}

Q.3.Given an integer n, return the nth ugly number.

Ugly number is a positive number whose prime factors only include 2, 3, and/or 5.

class Solution {
    public int nthUglyNumber(int n) {
        int[][] dp = new int[3][n + 1];
        int result = 1;
        int a = 0;
        int b = 0;
        int c = 0;

        for (int i = 0; i < n - 1; i++) {
            dp[0][i] = result * 2;                                  \\ 2 4 6 8 10 12 14
            dp[1][i] = result * 3;                                  \\ 3 6 9 12 15 18 24
            dp[2][i] = result * 5;                                   \\5 10 15 20 25 30 40

            result = Math.min(Math.min(dp[0][a], dp[1][b]), dp[2][c]);   \\1 2 3 4 5 6 8 9 10 12 15 16 18 20

            if (result == dp[0][a])
                a++;

            if (result == dp[1][b])
                b++;

            if (result == dp[2][c])
                c++;
        }
        return result;

    }
}
